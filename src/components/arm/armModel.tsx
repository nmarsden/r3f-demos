/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.13 public/arm/robohand-2.glb -o robohand2Model.tsx --transform -j --types
Files: public/arm/robohand-2.glb [68.43MB] > robohand-2-transformed.glb [2.57MB] (96%)
*/

import * as THREE from 'three'
import {Html, useGLTF} from '@react-three/drei'
import {GLTF} from 'three-stdlib'
import {useEffect, useMemo, useState} from "react";
import {animated, config, SpringValue, useSprings} from '@react-spring/three'
import "./arm.css"

type GLTFResult = GLTF & {
  nodes: {
    Object_10: THREE.Mesh
    Object_10001: THREE.Mesh
    Object_10002: THREE.Mesh
    Object_11: THREE.Mesh
    Object_12: THREE.Mesh
    Object_13: THREE.Mesh
    Object_14: THREE.Mesh
    Object_15: THREE.Mesh
    Object_16: THREE.Mesh
    Object_16001: THREE.Mesh
    Object_17: THREE.Mesh
    Object_2001: THREE.Mesh
    Object_3: THREE.Mesh
    Object_4: THREE.Mesh
    Object_4001: THREE.Mesh
    Object_4002: THREE.Mesh
    Object_4003: THREE.Mesh
    Object_4004: THREE.Mesh
    Object_5: THREE.Mesh
    Object_6: THREE.Mesh
    Object_7: THREE.Mesh
    Object_8: THREE.Mesh
    Object_9: THREE.Mesh
  }
  materials: {
    Default: THREE.MeshStandardMaterial
  }
}

const MESH_NAMES = new Map<string, string>();
MESH_NAMES.set('Object_10', 'Upper Arm');
MESH_NAMES.set('Object_10001', 'Finger Two');
MESH_NAMES.set('Object_10002', 'Shoulder');
MESH_NAMES.set('Object_11', 'Finger Two');
MESH_NAMES.set('Object_12', 'Thumb');
MESH_NAMES.set('Object_13', 'Thumb');
MESH_NAMES.set('Object_14', 'Thumb');
MESH_NAMES.set('Object_15', 'Upper Arm');
MESH_NAMES.set('Object_16', 'Upper Arm');
MESH_NAMES.set('Object_16001', 'Finger One');
MESH_NAMES.set('Object_17', 'Upper Arm');
MESH_NAMES.set('Object_2001', 'Finger Two');
MESH_NAMES.set('Object_3', 'Forearm');
MESH_NAMES.set('Object_4', 'Elbow');
MESH_NAMES.set('Object_4001', 'Finger One');
MESH_NAMES.set('Object_4002', 'Wrist');
MESH_NAMES.set('Object_4003', 'Forearm');
MESH_NAMES.set('Object_4004', 'Forearm Heatsink');
MESH_NAMES.set('Object_5', 'Palm');
MESH_NAMES.set('Object_6', 'Finger One');
MESH_NAMES.set('Object_7', 'Finger Three');
MESH_NAMES.set('Object_8', 'Finger Three');
MESH_NAMES.set('Object_9', 'Finger Three');

const NODE_NAMES = [...MESH_NAMES.keys()];

type Positions = { position: number[], displacement: number[] };

export function ArmModel({ opacity, ...props}: JSX.IntrinsicElements['group'] & { opacity: SpringValue }) {
  const [anyHovered, setAnyHovered] = useState(false);
  const [hoveredMesh, setHoveredMesh] = useState([...NODE_NAMES].map(() => false));
  const [exploded, setExploded] = useState(false);
  const {nodes, materials} = useGLTF('/arm/robohand-2-transformed.glb') as GLTFResult
  const isTransitioning = opacity.isAnimating;

  // Reset exploded if necessary when transitioning in/out
  if (isTransitioning && exploded) {
    setExploded(false);
  }

  const { targetMap, positions } = useMemo(
    () => {
      const targetMap: Map<string, Positions> = new Map<string, Positions>();
      const explosionCenter = new THREE.Vector3(0, 0, 0);
      const explosionFactor = 0.5;

      Object.keys(nodes).forEach(nodeKey => {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const mesh: THREE.Mesh = nodes[nodeKey];
        if (mesh.name.startsWith('Object')) {

          const position: THREE.Vector3 = mesh.position;

          const vector = position.clone().sub(explosionCenter).normalize();
          const displacement = position.clone().add(
            vector.multiplyScalar(
              position.distanceTo(explosionCenter) * explosionFactor
            )
          );
          targetMap.set(mesh.name, { position: [ position.x, position.y, position.z ], displacement: [ displacement.x, displacement.y, displacement.z ] } );
        }
      })
      const positions: Positions[] = Array.from(targetMap.values());

      return { targetMap, positions };
    },
    []
  );

  const [springs, api] = useSprings(
    targetMap.size,
    (index) => ({
      from: {
        position: positions[index].position
      },
      position: positions[index].position,
      config: config.stiff
    })
  );

  useEffect(() => {
    api.start(index => ({
      position: exploded ? positions[index].displacement : positions[index].position,
    }))
  }, [exploded]);

  useEffect(() => {
    document.body.style.cursor = anyHovered ? 'pointer' : 'auto'
    return () => {
      document.body.style.cursor = 'auto';
    }
  }, [anyHovered])

  useEffect(() => {
    setAnyHovered(hoveredMesh.some(h => h))
  }, [hoveredMesh])

  return (
    <group {...props}
           dispose={null}
           onClick={(event) => {
             setExploded(!exploded);
             event.stopPropagation();
           }}
    >
      {
        [...NODE_NAMES].map((nodeName, index) => {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          const mesh: THREE.Mesh = nodes[nodeName];
          return <animated.mesh
            key={nodeName}
            geometry={mesh.geometry}
            castShadow={true}
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            position={springs[index].position}
            rotation={[-Math.PI / 2, 0, 0]}
            onPointerOver={(event) => {
              setHoveredMesh(prevState => prevState.map((item, idx) => {
                return (index === idx) ? true : item;
              }));
              event.stopPropagation();
            }}
            onPointerOut={() => {
              setHoveredMesh(prevState => prevState.map((item, idx) => {
                return (index === idx) ? false : item;
              }));
            }}
          >
            {/* eslint-disable-next-line @typescript-eslint/ban-ts-comment */}
            {/* @ts-ignore */}
            <animated.meshStandardMaterial
              {...materials.Default}
              transparent={true}
              opacity={opacity}
            />
            <Html wrapperClass={'annotation-wrapper'}>
              <div className={`annotation ${hoveredMesh[index] ? 'show' : ''}`}>{MESH_NAMES.get(nodeName)}</div>
            </Html>
          </animated.mesh>
        })
      }

      {/*<mesh geometry={nodes.Object_10.geometry} material={materials.Default} position={[-0.232, 4.245, -9.919]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_10001.geometry} material={materials.Default} position={[0.008, 0.659, 17.986]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_10002.geometry} material={materials.Default} position={[0.006, -0.016, -14.494]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_11.geometry} material={materials.Default} position={[0.007, 0.829, 15.737]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_12.geometry} material={materials.Default} position={[-3.889, -0.242, 14.976]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_13.geometry} material={materials.Default} position={[-3.986, -0.242, 12.717]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_14.geometry} material={materials.Default} position={[-3.332, -0.242, 11.356]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_15.geometry} material={materials.Default} position={[2.64, -3.161, -8.588]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_16.geometry} material={materials.Default} position={[2.814, 3.225, -8.523]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_16001.geometry} material={materials.Default} position={[-1.412, 0.708, 14.166]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_17.geometry} material={materials.Default} position={[-3.845, 1.336, -8.587]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_2001.geometry} material={materials.Default} position={[0.007, 0.708, 14.166]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_3.geometry} material={materials.Default} position={[-0.098, -0.086, 0.359]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_4.geometry} material={materials.Default} position={[-1.51, -2.07, -4.618]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_4001.geometry} material={materials.Default} position={[-1.412, 0.659, 17.986]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_4002.geometry} material={materials.Default} position={[0.007, -0.036, 6.432]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_4003.geometry} material={materials.Default} position={[0.104, 2.511, 4.416]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_4004.geometry} material={materials.Default} position={[-5.099, 0.369, -0.006]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_5.geometry} material={materials.Default} position={[-0.255, 0.426, 10.505]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_6.geometry} material={materials.Default} position={[-1.412, 0.829, 15.737]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_7.geometry} material={materials.Default} position={[1.427, 0.708, 14.166]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_8.geometry} material={materials.Default} position={[1.427, 0.829, 15.737]} rotation={[-Math.PI / 2, 0, 0]} />*/}
      {/*<mesh geometry={nodes.Object_9.geometry} material={materials.Default} position={[1.427, 0.659, 17.986]} rotation={[-Math.PI / 2, 0, 0]} />*/}
    </group>
  )
}

useGLTF.preload('/arm/robohand-2-transformed.glb')
